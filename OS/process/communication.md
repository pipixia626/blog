# 进程间通信
每个进程的用户地址空间都是独立的，一般而言是不能相互访问的，但内核空间是每个进程都要共享的，所以进程之间通信必须通过内核


## 管道
- 匿名管道：用完就销毁  `$ ps auxf | grep mysql` 将前一个命令的输出作为后一个命令的输入，管道传输数据是单向的，要向相互通信，需要创建两个管道才行 通信范围是存在父子关系的进程
- 命名管道 FIFO ：数据是先进先出的传输方式 
通过 `$ mkfifo myPipe   `可以在不相关的进程间也能相互通信

### 原理
管道以文件的方式存在的，也就是内核里面的缓存，因此通信效率低，不适合进程频繁地交换数据，但是比较简单
进程的写入和读出都是缓存在内核中，通信数据都遵循先进先出原则，数据格式是无格式的字节流

生命周期随着进程的创建而开始，进程的结束而销毁

## 消息队列
消息队列是保存在内核中的消息链表，在发送数据时，会分成一个一个独立的数据单元，也就是消息体，消息体是用户自定义的数据类型，消息的发生方和接收方要约定好消息体的数据类型，每个消息体都是固定大小的存储块，不像管道是无格式的字节流数据

生命周期随着内核，如果没有释放消息队列或者没有关闭操作系统，消息队列会一直存在

这样两个进程之间的通信就可以频繁沟通了

- 缺点
通信不及时 ->存在用户态和内核态之间的数据拷贝开销
附件有大小限制 ->不适合较大数据的传输，因为在内核中每个消息体都有一个最大长度的限制

## 共享内存
消息队列的读取和写入的过程，都会发生用户态和内核态之间的消息拷贝过程，共享内存的方式就很好地解决这一问题

### 原理
拿出一块虚拟地址，映射到相同的物理内存中，这样就不需要拷贝来来去去的
## 信号量
用了共享内存通信的方式，就会带来新的问题，如果多个进程同时修改同一个共享内存，就会有冲突，为了防止多进程竞争共享资源而造成数据错乱，所以需要保护机制，因此信号量就实现了这一保护机制

信号量其实就是一个整型的计数器，主要用于实现进程间的互斥和同步


信号量表示资源的数量

p：申请资源

v：释放资源
## 信号
上面的进程间通信，都是常规状态下的工作模式，对于异常情况下的工作模式，就需要用信号来通知进程

信号事件的主要来源有硬件来源(ctrl c)和软件来源(kill)

信号是进程间通信机制中唯一的异步通信机制，因为可以在任何时候发送给某一进场，一旦有信号产生，就有如下几种用户进程对信号的处理方式
1. 执行默认操作
2. 步骤信号
3. 忽略信号
## socket
想要跨越网络与不同主机上的进程之间通信，就需要socket，
实际上，socket通信还可以在同主机上进程间通信(local)

tcp /udp

### tcp
tcp server: create->bind->listen->accept->send/recv->close

tcp client:create->connect ->send/recv->close
### udp
udp server: create->bind->send/recv->close
udp client: create->send/recv->close