## 基本概念
### 临界资源
一次仅允许一个进程使用的资源称为临界资源。物理设备、变量、数据等待

可以根据临界资源的访问资源划分几个部分
```
do {
    entry section; //进入临界区 检查、分布资源、上锁
    critical section;//临界区 访问临界资源
    exit section;   //退出区  释放资源，解锁
    remainder section;//剩余区 剩余的代码
}while(ture)


```
### 同步(直接制约关系)
协调进程的工作次序

### 互斥(间接制约关系)
临界资源一次只能一个进程占用

### 同步机制应遵循的原则
- 空闲让进  
- 忙则等待
- 有限等待
- 让权等待

### 信号量
信号量只能被两个标准的原语wait(S)和signal(S) PV操作
硬件的原子操作可以由软件通过中断来完成

P:申请资源，V：释放资源

#### 整型信号量
整型信号量S表示资源的数目，wait操作和signal操作
```
wait(S){
    while(S<=0);
    S=S-1;
}
signal(S){
    S=S+1;
}
```
会忙等，因为有while循环
#### 记录型信号量
```
typedef struct{
    int value;//资源数目
    struct process *L//该资源的进程链表
} semaphore;
```
PV操作

```
void wait(semaphore S){
    S.value--;
    if(S.value<0){
        add this process to S.L;//让此进程也加入等待资源的队列
        block(S.L);//让当前进程进入阻塞态
    }
}
```

```
void signal(semaphore S){
    S.value++;
    if(S.value<=0){
        remove a process P from S.L;
        wakeup(P);
    }
}
```
不会忙等，而是在缺少资源时直接阻塞，而不是一直循环，体现了让权等待

#### 利用信号量实现同步
两个进程为了让y操作能在x操作之后执行，在x操作后面进行v操作，在y操作之前进程p操作就可以了
#### 利用信号量实现互斥
```
semaphore S=1; //初始化信息量
P1(){
    ...
    P(S);    //准备开始访问临界资源，加锁
    进程P1的临界区
    V(S);    //访问结束，解锁
    ...
}
P2(){
    ...
    P(S);    //准备开始访问临界资源，加锁
    进程P2的临界区
    V(S);    //访问结束，解锁
    ...
}
```
#### 利用信号量实现前驱关系
有多少对前驱关系就用多少个信号量表示
## 生产者-消费者问题
- 一组生产者和一组消费者互斥的使用一些缓冲区，生产者复杂生产产品到缓存区，消费者负责使用
- 生产者和消费者同步关系；生产者之间互斥关系，使用缓存区也是互斥关系
- 确定信号量mutex=1表示缓存区互斥，empty=n表示缓存区数量；full=0表示初始生产的数量



## 读者-写者问题
- 读者之间关系，写者之间关系，读者和写者之间的关系
- 需要一个计数器来记录读者进程的数量


## 哲学家就餐问题
