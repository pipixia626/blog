# 分段和分页的区别

## 分页存储管理

### 基本思想

用户程序的地址空间被划分成若干个固定大小的区域，称为“页”,相应地，内存空间分成若干个物理块，页和块的大小相等，可将用户程序的任一页
放在内存的任一块中，实现离散分配

若给定一个逻辑地址为A，页面大小为L，则
页号P=INT[A/L]，页内地址W=A  MOD  L

### 页表
分页系统中，允许将进程的每一页离散地存储在内存的任一物理块中，为了能在内存中找到每个页面对应的物理块，
系统为每个进程建立一张页面映射表，简称页表。页表的作用是实现从页号到物理块号的地址映射。

### 页表：

页号 物理块号 存取控制   

  0        2    

  1       15（F）    

  2       14（E）    

  3       1  

## 分段存储管理

### 基本思想
将用户程序地址空间分成若干个大小不等的段，每段可以定义一组相对完整的逻辑信息。存储分配时，以段为单位，段与段在内存中可以不相邻接，
也实现了离散分配。
###  段表
段号 段长 起始地址 存取控制   

0     1K     4096    

1     4K     17500    

2     2K     8192  

## 区别：

### 目的

页是信息的物理单位，分页是为实现离散分配方式，以消减内存的外零头，提高内存的利用率，出于系统管理的需要而不是用户需要
端是信息的逻辑单位，含有一组其意义相对完整的信息，分段的目的是为了更好地满足用户的需要

### 长度
在linux中，默认页的大小为4KB，1MB->256页
页的大小固定而且由系统决定，由系统把逻辑地址分为页号和页内地址两部分，是由机器硬件实现的
段的长度不固定，由用户所编写的程序决定，通常由编译程序对程序编译时，根据信息的性质来划分

### 地址空间

分页的作业地址空间是一维的.
分段的地址空间是二维的.段的长度由相应的逻辑信息组的长度决定，因而各段长度不等。整个作业的地址空间是二维的。

### 碎片

【内部碎片】
内部碎片就是已经被分配出去（能明确指出属于哪个进程）却不能被利用的内存空间；
内部碎片 是处于 （操作系统分配的用于装载某一进程的内存）区域内部 或页面内部 的存储块。占有这些区域或页面的进程并不使用这个 存储块。而在进程占有这块存储块时，系统无法利用它。直到进程释放它，或进程结束时，系统才有可能利用这个存储块。
单道连续分配只有内部碎片。 多道固定连续分配既有内部碎片，又有外部碎片。
【外部碎片】
外部碎片指的是还没有被分配出去（不属于任何进程），但由于太小了无法分配给申请内存空间的新进程的内存空闲区域。
外部碎片是处于任何两个已分配区域或页面之间的空闲存储块。这些存储块的总和可以满足当前申请的长度要求，但是由于它

### 绝对地址

分页有内部碎片无外部碎片

分段有外部碎片无内部碎片
处理器使用页号和偏移量计算绝对地址

处理器使用段号和偏移量计算绝对地址
### 管理方式

对于分页，操作系统必须为每个进程维护一个页表，以说明每个页对应的的页框。当进程运行时，它的所有页都必须在内存中，除非使用覆盖技术或虚拟技术，另外操作系统需要维护一个空闲页框列表。

对于分段，操作系统必须为每个进程维护一个段表，以说明每个段的加载地址和长度。当进程运行时，它的所有短都必须在内存中，除非使用覆盖技术或虚拟技术，另外操作系统需要维护一个内存中的空闲的空洞列表。

### 共享和动态链接
分页不容易实现，分段容易实现

### 二者关系

1、paging是操作系统管理physical address的机制，这对用户来说是透明的，用户并不知道自己的进程是如何被paged的；而segmentation是从用户的视角（user’s view）来分割内存的机制，用户知道自己的程序是如何被分段的，而且用户可以自己决定自己的程序是如何分的段。

2、paging是对内存空间（注意，分割对象是内存空间）按地址等长（注意，划分依据是地址，所以是等长的）分割，主要是为了解决contigious allocation中的external fragmentation问题，提高内存的利用率（注意，目的是充分利用内存）；而segmentation是对程序内容（注意，分割对象是程序内容）按语义（注意，划分依据是语义，所以是变长的）分割，把相似属性的数据划分开来，从而便于保护（比如代码段的内容不允许被修改）和共享（比如代码段的数据可以被共用）（注意，目的是保护和共享）。

3、segmentation和paing原本都是将logical address映射到physical address的方式，两者都是noncontigious allocation的具体实现，它们原本的地位是平行的。但是，二者可以结合起来用，即“segmentation with paging”，此时，segmentation在上层，与用户打交道，paging是下层，与physical memory space打交道。一段程序，先按语义分割成各个长度不一的segments，每个segment再等长分割成长度相同的多个pages。如此一来，用户地址访问内存则需要两步查表，第一步先查segment table找到对应的segment，把logical address映射成linear address，再用linear address对page table查表，从而转化成真正的physical address。具体实现的过程与上述有点点不一样，具体实现时，第一步查找的不是简单的segment table，而是通过selector查找global descriptor table，再根据找到的表项去查page table，selector中不仅包含了segment位置相关的信息，还包含了与保护等相关的信息。

4、打个比方，你现在有一整头猪肉（对应进程），要把它放进冰箱（对应物理内存）里。paging就是先把冰箱按照位置划分成一样大小的空格（对应frame），再把一整头猪肉也按空格一样大小来切碎再放进去。segmentation就是先把猪按照猪头、猪肘、内脏、里脊等等切成一块一块的，把这些块（对应segment）塞进冰箱里。而segmentation with paging就是一边把猪肉按部位切块，另一边把冰箱等空格划分，再把各个部位进行再切碎，填进每一个小格子里。
