# 进程同步问题

## 进程并发访问共享的数据导致数据不一致问题

### 典型问题

生产者-消费者问题<br>
共享内存解决方案<br>

### 互斥产生原因
进程宏观上并发执行，依靠时钟中断来实现微观上轮流执行，访问共享资源

### 互斥定义
在同一时刻，只运行一个进程访问该共享数据，即如果当前已有一个进程正在使用该数据，那么其他进程就不能访问


## 临界区问题

### 临界区资源
在一个时间段内只允许一个进程访问的资源

### 满足
1：互斥
2：空闲让进
3：有限等待

### 基于繁忙等待的策略：
当一个进程想要进入临界区，首先检查一下是否允许它进入，若允许，直接进入，
若不允许，在那里循环等待

#### 缺点：
浪费CPU时间
可能导致死锁

#### 解决：

当一个进程无法进入临界区，应该被阻塞
当一个进程离开临界区，应该被唤起


### 新的互斥形式
两个或多个进程想进入自己的临界区，在任何时候，只允许N个进程同时进入临界区


## 信号量
不需要繁忙等待
整型信号量
operations:wait(),signal()
原子操作
即为:
p():->wait()
v():->signal()

### 使用方式
1：计数信号量
2：二进制信号量（互斥信号量）

缺点：产生自旋锁：需要等待别人释放才能使用
死锁：两个或两个以上的进程在无限等待一个事件，而这个事件就只能由一个等待进程引起
饥饿：无限地阻塞，永远不会被挂起（两个进程使用的信号量都初始化为1）

## 实际问题
生产者-消费者问题<br> 
读者-写着问题<br>
哲学家就餐问题<br>
