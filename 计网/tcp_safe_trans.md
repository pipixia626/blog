# TCP协议
TCP是一个可靠，面向字节流的传输协议
如何保证可靠呢(数据的破坏，丢包，重复以及分片顺序混乱等问题）

TCP是通过序列号，确认应答，重发控制，连接管理以及窗口控制实现可靠性传输的


## 重传机制
背景：当发送端的数据到达接收主机时，接收端主机会返回一个确认应答消息，表示已收到消息


### 超时重传

定时器(RTT Round-Trip Time )
超时重传时间RTO的值应该略大于报文往返RTT值

### 快速重传
不以时间为驱动，而以数据驱动重传

三次同样的ACK就会触发重发机制

#### 解决问题
解决超时时间的问题，但面临另外一个问题

依然面临着另外一个问题。就是重传的时候，是重传之前的一个，还是重传所有的问题。
### SACK
 TCP 头部「选项」字段里加一个 SACK 的东西，它可以将缓存的地图发送给发送方，
 这样发送方就可以知道哪些数据收到了，哪些数据没收到，知道了这些信息，就可以只重传丢失的数据
### D-SACK

## 滑动窗口
解决等待只有等待对方数据包确认应答中的苦苦等待问题
窗口就是缓存的
有了窗口，就可以指定窗口大小，窗口大小就是指无需等待确认应答，而可以继续发送数据的最大值

TCP头里面有一个字段叫Winodw，也就是窗口的大小，用于接收端告诉发送端自己还有多少缓冲区可以接收数据

### 发送窗口

### 接收窗口

接收窗口和发送窗口的大小是相等的吗？

并不是完全相等，接收窗口的大小是约等于发送窗口的大小的

根据数据报传输情况实时变化

## 流量控制
由滑动窗口协议（连续ARQ协议）实现。滑动窗口协议既保证了分组无差错、有序接收，也实现了流量控制。
主要的方式就是接收方返回的 ACK 中会包含自己的接收窗口的大小，并且利用大小来控制发送方的数据发送。
### 操作系统缓冲区和滑动窗口关系
窗口关闭

## 拥塞控制
前面的流量控制是避免「发送方」的数据填满「接收方」的缓存，但是并不知道网络的中发生了什么。

在网络出现拥堵时，如果继续发送大量数据包，可能会导致数据包时延、丢失等，这时 TCP 就会重传数据，但是一重传就会导致网络的负担更重，
于是会导致更大的延迟以及更多的丢包，这个情况就会进入恶性循环被不断地放大

前者关注两端的发送和接收的控制
后者关注传输过程中的控制
### 拥塞窗口
拥塞窗口 cwnd是发送方维护的一个的状态变量，它会根据网络的拥塞程度动态变化的。
发送窗口 swnd 和接收窗口 rwnd 是约等于的关系，那么由于加入了拥塞窗口的概念后，
此时发送窗口的值是swnd = min(cwnd, rwnd)，也就是拥塞窗口和接收窗口中的最小值

### 拥塞窗口变化规则
只要网络中没有出现拥塞，cwnd 就会增大；
但网络中出现了拥塞，cwnd 就减少

### 如何知道当前网络是否出现了拥塞
其实只要「发送方」没有在规定时间内接收到 ACK 应答报文，也就是发生了超时重传，就会认为网络出现了用拥塞。
### 慢启动
当发送方每收到一个 ACK，拥塞窗口 cwnd 的大小就会加 1。
#### 慢启动什么时候停止
有一个叫慢启动门限 ssthresh （slow start threshold）状态变量。

当 cwnd < ssthresh 时，使用慢启动算法。
当 cwnd >= ssthresh 时，就会使用「拥塞避免算法」
一般来说 ssthresh 的大小是 65535 字节。

### 拥塞避免
那么进入拥塞避免算法后，它的规则是：每当收到一个 ACK 时，cwnd 增加 1/cwnd。
由质数增长变成了线性增长

### 拥塞发生
当发生了「超时重传」，则就会使用拥塞发生算法。

这个时候，ssthresh 和 cwnd 的值会发生变化：

ssthresh 设为 cwnd/2，
cwnd 重置为 1
### 快速恢复
TCP 认为这种情况不严重，因为大部分没丢，只丢了一小部分，则 ssthresh 和 cwnd 变化如下：

cwnd = cwnd/2 ，也就是设置为原来的一半;
ssthresh = cwnd;
进入快速恢复算法
快速重传和快速恢复算法一般同时使用，快速恢复算法是认为，你还能收到 3 个重复 ACK 说明网络也不那么糟糕，所以没有必要像 RTO 超时那么强烈。

正如前面所说，进入快速恢复之前，cwnd 和 ssthresh 已被更新了：

cwnd = cwnd/2 ，也就是设置为原来的一半;
ssthresh = cwnd;
然后，进入快速恢复算法如下：

拥塞窗口 cwnd = ssthresh + 3 （ 3 的意思是确认有 3 个数据包被收到了）；
重传丢失的数据包；
如果再收到重复的 ACK，那么 cwnd 增加 1；
