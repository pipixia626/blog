# linux进程调度

## preview
调度程序即决定了多个程序运行策略，调度程序的最大原则在于能够最大限度地利用计算机资源

## 架构
调度策略是模块化设计的，调度器根据不同的进程依次遍历不同的调度策略，找到进程对应的调度策略，调度的结果为选出一个可运行的进程指针，并将其加入到进程可运行队列中

1. CFS SCHED_NORMAL
所有进程实际占用处理器CPU实际应为一致，目的是确保每个进程公平的使用，即最大化地利用计算资源
2. FIFO  SCHED_FIFO
一旦处于当前级别的进程处于可执行的状态，它就会一致运行，直到进程阻塞或主动释放
3. RR  SCHED-RR
在耗尽事先分配的时间片之后就不会指向

FIFO和RR调度算法都为静态优先级。内核不为实时进程计算动态优先级，保证了优先级别高的实时进程总能抢找优先级比它低的进程。

## CFS

1. 时间进账
2. 进程选择
3. 调度器入口
4. 睡眠和唤醒

### 数据结构
1. task_struct :为进程任务，存储进程相关信息
2. sched_entity :存储进程调度相关信息，其中run_node为可执行红黑树的节点
3. ofs_rq 存储着rb_root,红黑树的根节点task_timeline
4. slab:对对象内存的一种高效的管理机制，可以有效的降低内存碎片

### 时间进账
所有的调度器都必须对进程的运行时间做记账。CFS不再有时间片的概念，维护了每个进程运行的时间记账，因为每个进程只在公平分配给它的处理器时间内运行。关键数据结构如下：
vruntime: 虚拟运行时间是在所有可运行基础的总数上计算出一个进程应该运行多久，计算时相应的nice值在CFS被作为进程获得处理器运行比的权重：越高的nice（越低优先级）值，获得更低的处理器权重，更低的nice值获得更高的处理器使用权重。
个人理解：CFS的vruntime += 处理器运行时间 * nice对应的权重

### 进程选择
进程选择是CFS调度算法的最重要的模块，当CFS调度器选择下一个要进行调度的进程时，就会选择具有最小vruntime的任务。涉及到获取最小值，以及有序数据结构，在各种场景下都很适用的红黑树就发挥了其作用。即用红黑树维护以vruntime为排序条件，存储着任务的运行情况。
进程的维护都在红黑树上进行相关操作：

### 调度器入口
进程调度器的入口函数为schedule()，总体流程即为选择合适的调度策略选出下一个需要被调度的进程任务，然后进行一次上下文切换，将进程置为运行态。

### 睡眠和唤醒
休眠（被阻塞）状态的进程处于不可执行的状态。进程休眠的原因有多种多样，但通常来说都是等待某一事件的发生，例如等待I/O, 等待设备输入等等。
内核对于休眠和唤醒的操作如下：

休眠：进程首先把自己标记为休眠状态(TASK_INTERRUPTIBLE)，然后从可执行红黑树中移除该进程，并将进程放入等待队列
唤醒：进程被置为可执行状态(TASK_RUNNING)，进程从等待队列移入可执行红黑树中
休眠或者阻塞状态有两种：可中断休眠(TASK_INTERRUPTIBLE), 不可中断休眠(TASK_UNINTERRUPTIBLE). 通常进程的休眠，为可中断休眠，即进程进入休眠，等待某一事件发生。一旦事件发生，或者满足条件，内核将会把进程状态置为运行，并将进程从等待队列中移除

### 抢占和上下文切换
抢占和上下文切换
上下文切换，处理器从即为从一个可执行的进程切换到另一个可执行的进程，其中包含了两个关键的函数.

switch_mm：把虚拟内存从上一个进程映射切换到新进程中
switch_to：负责将上一个处理器状态信息切换到新进程的处理器状态。包括保存，恢复栈信息和寄存器信息。
内核必须知道在什么时候需要调用schedule()来执行一次调度, 而不是靠用户去执行schedule()函数，为此内核提供了一个need_resched标志位，表明是否需要重新进行一次调度。
need_resched标志位为1时会触发内核进行一次调度，有如下几个情况：

1. 用户态抢占(重新调度)
    1. 从系统调用返回用户空间时，read，write，syscall
    2. 从中断处理程序返回用户空间时，硬件中断，时钟中断(类似于时间片的概念)，等等
2. 内核态抢占(重新调度)
    1. 中断处理程序正在执行，且返回内核空间之前
    2. 内核代码再一次具有可抢占性的时候
    3. 内核任务显式的调用schedule()
    4. 内核任务阻塞
