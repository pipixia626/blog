# 构造函数和析构函数

## 构造函数
构造函数用来处理对象的初始化

1.构造函数是一种特殊的成员函数，不需要用户来调用，定义对象时被自动执行。　

2.构造函数名字与类名相同，无返回类型。　

3.可以由用户自己定义实现，根据需要设计对数据成员进行初始化，依旧可以设置函数的默认参数。

4.如果我们没有定义构造函数，系统会为我们自动定义一个无参的默认构造函数的，它不对成员属性做任何操作，
如果我们自己定义了构造函数，系统就不会为我们创建默认构造函数了。

## 析构函数
它的作用与构造函数相反，一般是执行对象的清理工作，当对象的生命周期结束的时候，
会自动的调用。析构函数的作用并不是删除对象，在对象撤销它所占用的内存之前，做一些清理的工作。
清理之后，这部分内存就可以被系统回收再利用了。在设计这个类的时候，系统也会默认的提供一个析构函数。
在对象的生命周期结束的时候，程序就会自动执行析构函数来完成这些工作。同构造函数，用户自己定义，系统自动调用。

1.析构函数没有返回值，没有参数；

2.没有参数，所以不能重载，一个类仅有一个析构函数；

3.析构函数除了释放工作，还可以做一些用户希望它做的一些工作，比如输出一些信息

## 构造函数不能是虚函数

1：存储空间
虚函数对应一个vtable，存储在对象的内存空间中，如果构造函数是虚的，就需要通过vtable来调用
可是对象还没有实例化，就是内存空间还没有，无法找到vtable，因此不能为虚的

2：使用角度
虚函数的作用在于通过父类指针或者引用来调用它的时候能够变成调用子类的那个成员函数。
而构造函数是在创建对象时自动调用的，不可能通过父类的指针或者引用区调用

## 析构函数可以是虚函数且最好是虚的
编译器总是根据类型来调用类成员函数，一个派生类的指针可以安全地转化为一个基类的指针
在删除一个基类的指针的时候，C++不管这个指针指向一个基类对象还是一个派生类的对象，调用的都是基类的构造函数而不是派生类的
。因为指针指向的是一个派生类实例，我们销毁这个实例时，肯定是希望即清理派生类自己的资源，同时又清理从基类继承过来的资源。而当基类的析构函数为非虚函数时，删除一个基类指针指向的派生类实例时，只清理了派生类从基类继承过来的资源，而派生类自己独有的资源却没有被清理，这显然不是我们希望的。


C++不把虚析构函数直接作为默认值的原因是虚函数表的开销以及和C语言的类型的兼容性。有虚函数的对象总是在开始的位置包含一个隐含的虚函数表指针成员。
