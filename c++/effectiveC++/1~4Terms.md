# Accustoming Youself to C++

## 视C++为一个语言联邦

- C
 C++仍是以C为基础 区块、语句、预处理器、内置数据类型、数组、指针等统统来自C

- Object-Oriented C++
 classes包括（构造函数和析构函数）,封装，继承，多态，动态绑定

- Template C++ 
C++泛型编程的部分，


- STL 
STL是一个template程序库，对容器，迭代器，算法以及函数对象的规约有极佳的紧密配合和协调

对于内置类型而言 pass by value 通常比pass by reference高效

对于用户自定义构造函数和析构函数的存在，pass by reference往往更好

### 结论
C++并不是一个带有一组守则的一体语言，它是从四个次语言组成的联邦政府，每个语言都有自己的规约从这四个次语言理解使用C++ 

## 尽量以const ,enum,inline 替换#define
#define不被视为语言的一部分
也许在编译器开始处理源码之前就被预处理器移走了，记号名称有可能没进入记号表

#define ASPECT_RATIO 1.653

当你使用这个常量来获得一个编译错误信息时，可能会因为追踪这个非你写的头文件而浪费时间

- 解决之道:  以一个常量替换上述的宏
const doule Aspect=1.653;//宏定义一般是大写的

使用常量可能比使用#define 导致较小量的码，引物预处理器“盲目地将宏名称ASPECT_RATIO”替换为1.653，可能导致目标码出现多份

### 特殊情况
1. 定义常量指针
由于常量定义式通常被放在头文件内（以便被不同的源码含入）
因此有必要将指针声明为const


2. class专属常量
为了将常量的作用域限制于class内，就必须让它称为class的一个成员，而为确保此常量至多只有一份实体

无法使用#define来创建一个class专属常量，引物#define并不重视作用域，一旦被定义，就在后面的编译过程中有效(除非在某处被#undef)->没有任何封装性

Enum和#define一样绝不会导致非必要的内存分配->取地址不合法

不想让别人获得一个pointer或者reference指向你的某个整数常量
### 总结
1. 对于单纯常量，最好以const对象或enums替换#define
2. 对于形似函数的宏，最好改用inline函数替换#define

## 尽可能使用 const
保护要不被修改的对象

最具威力：面对函数声明时的应用

使pass by reference-to-const 方式传递对象

用于重载
### 总结
1. 将某些东西声明为const可帮助编译器侦测出错误用法，const可被施加于任何作用域内的对象，函数参数，函数返回类型，成员函数本体

2. 当const和non_const成员函数有着实质性等价的实现时
为了避免代码重复的函数重载
用non_const ->调用const ->类型转换 两次（static_cast添加和const_cast删除）

## 确定对象被使用前先被初始化
读取未初始化的值会导致不明确的行为

- 使用C part of C++ 初始化可能导致运行期的成本，就不保证初始化

- non-C parts of C++ 初始化规则有变化

因此：永远在使用对象之前先将它初始化

对于内置类型->手动初始化

内置类型之外的东西->构造函数：确保每一个构造函数都将对象的每一个成员初始化


### 赋值和初始化的区别
C++规定，对象的成员遍历的初始化动作发生在进入构造函数本体之前 ->使用成员函数列表初始化（效率更高）
避免了构造函数调用defaut构造函数为成员变量设初值再立刻对他们赋予新值

赋值操作是在两个已经存在的对象间进行的，而初始化是要创建一个新的对象，并且其初值来源于另一个已存在的对象。 编译器会区别这两种情况，赋值的时候调用重载的赋值运算符，初始化的时候调用拷贝构造函数
比起先调用default构造函数然后再调用copy assignment操作符，只调用一次copy构造函数


初始化顺序：
1. base->derived
2.  base里面安声明顺序

- 例外
不同编译单元内定义之non_local static 对象的初始化对象(初始化顺序无明确定义)

解决办法将每个non_local static 对象搬到自己的专属函数内non-loacl对象被loacl static对象替换了

因为函数内的local static对象会在“该函数被调用期间”首次遇上该对象之定义式时初始化（reference_returning)


### 总结
1. 为内置型对象进行手工初始化，因为C++不保证初始化它们
2. 使用成员初值列表初始化对象的所有成分
3. 在初始化次序不确定性氛围下加强设计
