# 类成员变量初始化的方法以及区别

## 初始化列表
```
class A
{
    public:
    int a;
    A (int a_):a(a_){}//初始化列表初始化
}
```

### 特点及使用场景
1. const成员变量只能用成员初始化列表来完成初始化，而不能在构造函数内赋值
2. 初始化的数据成员是对象
3. 需要初始化引用成员数据
## 构造函数初始化
```
class A{
    public:
    int a;
    A(int a_){a=a_;}//构造函数初始化
}
```
### 特点及使用场景

## 声明时初始化
```
class A{
    public:
    int a=1;//声明时初始化
    A(){}
}
```

### 特点及使用场景
1. 直观
2. 定义多个构造函数时，每个构造函数都用列表初始化的方法效率不高


## 区别

这三种初始化都在用
成员变量的初始化顺序是
声明时初始化->初始化列表->构造函数初始化

类定义成员变量并直接赋值的方式的意义：以往使用初始化列表或构造函数对类进行初始化时，每定义一个类对象就要把特定的值传给每个成员变量，但有时类的某些成员变量使用默认值即可，不用每定义一个对象都要指定，这时在定义成员变量并直接赋值的方式非常方便。 网上也有更加通俗的类比： 好比一台机器能够生产某种零件，零件的各个尺寸可以在一定程度任意改变，但是我们并不是每次生产这种零件都需要一个一个地给定每一个参数，然后再生产，机器会自己带有一套“默认”的零件尺寸参数，这样新手可以直接用默认参数生产，除非你知道每一个参数都是干啥的，否则没必要更改。那么也可以在构造函数中给出这一套“默认参数”啊，是的，但是假如你有10个构造函数，那么你每一个都要复制一次所有成员变量的默认参数吗？显然在做重复的无用工作，那么为什么不直接在声明的时候就初始化！


主要是性能问题，对于内置类型，如int, float等，使用初始化类表和在构造函数体内初始化差别不是很大，但是对于类类型来说，最好使用初始化列表，为什么呢？由下面的测试可知，使用初始化列表少了一次调用默认构造函数的过程，这对于数据密集型的类来说，是非常高效的
