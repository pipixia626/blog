# 三大特性


## 封装
隐藏实现细节，使得代码模块化 :private,public
## 继承
多个类中存在相同属性和行为时，将这些内容抽取到单独一个类中，那么多个类无需再定义这些属性和行为，只要 继承那一个类即可。
扩展已存在的代码模块，目的是为了代码重用:protected
## 多态
通过指向父类的指针，来调用在不同子类实现的方法目的是为了接口重用，同一种行为不同种表现形式

### 多态的实现

三个重要的组成部分
1：相同的函数名
2：依赖于上下文
3：具有不同的实现机制

多态实现方式
函数重载，模板函数和虚函数

### 编译时多态
在编译器即确定的多态，决定了同一函数名的函数如何利用参数来进行调用，

#### 函数重载
允许不同参数的函数有相同的名字，通过不同的参数列表来对函数进行重命名，由于无法对返回值重载，因此就需要函数模板来完成多态

#### 模板函数
采用了自定义类型template来定义一个函数，即函数参数的参数类型是待定的，但是函数的参数个数是确定的。

单单采用函数模板并不是多态，因为虽然实现了不同类型的同函数调用，但是还是使用了同一个模板函数的定义，
核心需要使用模板特化的功能来讲需要进行多态的函数进行特化

### 运行时多态
函数在程序执行的过程中才能确定的真正执行的函数

#### 多态的实现
基类中声明有待virtual关键字的函数，派生类对该函数进行重写，在使用基类指针指向派生类时，即可调用派生类所实现的虚函数内容从而实现多态

#### 为什么运行时多态不能在编译器确定
不知道运行中多提供的对象类型，只能知道使用基类指针来指向这个对象
```
//比如此函数，基类指针的指向只由code来决定，而编译期是无法决定这个函数基类指针的指向的，
//只有在运行时，对于每个给定的code来动态的返回对应的派生类对象。
base* do_something(int code) {
    switch(code){
        case 1:
            return new A();
        case 2:
            return new B();
        default;
            return nullptr;
    }
}
```
#### 为什么析构函数需要写出虚函数
为了防止内存泄漏，当用基类指针指向派生类对象时，销毁对象的过程只会调用基类的析构函数，故会存在值析构了基类的内容
而没有销毁派生类的专属内容，只有将基类的析构函数也声明位虚函数，析构时才会调用派生类的析构函数

### 虚函数实现原理
利用函数表指针指向一个虚函数表的起始位置，虚函数表存放该类中的虚函数指针，调用时可以找到虚函数表指针，通过虚函数表指针找到
虚函数表，再利用虚函数表的偏移找到函数的入口，从而找到要使用的虚函数

当派生类重新定义了基类的函数后其虚函数表中的指针发生了覆盖，而没有重写的地方则维持了基类虚函数的地址。

### 虚表


