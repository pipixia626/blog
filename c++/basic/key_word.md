# 关键字

## define
进入编译器的预处理阶段，就把源码中相应定义替换成设定的值

## static
### static 成员变量
1：静态成员变量是该类的所有对象所共享的，
在全局数据区分配内存，由本类的所有对象共享，不属于特定类型，不占用对象的内存，而是在所有对象之外开辟内存，在没有产生类对象时其作用域就可见
因此，在没有类的实例存在时，静态成员变量就已经存在，可以访问

需要初始化，内存空间在编译时，初始化分配的，只能在类体外进行，只有到程序结束时才释放

有同样的private,public,protected访问规则


### static 成员函数
不像普通成员函数那样具有this指针，this指针指向类的对象本身，因为普通成员函数总是具体的属于哪里具体对象，当函数被调用时,系统会把
当前对象的起始地址赋给this指针，通常情况下，this是缺省的

因为不具有This指针，因此只能调用其余的静态函数成员和静态成员变量
另外一个角度：由于静态成员函数和静态成员变量在类实例化之前就已经存在可以访问，而此时非静态成员还是不存在的，因此静态成员不能访问非静态成员
### static 全局变量
该变量在全局数据区分配内存；

未经初始化的静态全局变量会被程序自动初始化为0（自动变量的自动初始化值是随机的）；

静态全局变量在声明它的整个文件都是可见的，而在文件之外是不可见的； 

静态变量都在全局数据区分配内存，包括后面将要提到的静态局部变量。对于一个完整的程序，在内存中的分布情况如下：【代码区】【全局数据区】【堆区】【栈区】，一般程序的由new产生的动态数据存放在堆区，函数内部的自动变量存放在栈区，静态数据（即使是函数内部的静态局部变量）存放在全局数据区。自动变量一般会随着函数的退出而释放空间，而全局数据区的数据并不会因为函数的退出而释放空间。

不会被其他文件所用，相同名字的变量不会发生冲突


### static 局部变量
静态局部变量在全局数据区分配内存； 

静态局部变量在程序执行到该对象的声明处时被首次初始化，即以后的函数调用不再进行初始化；

静态局部变量一般在声明处初始化，如果没有显式初始化，会被程序自动初始化为0；

静态局部变量始终驻留在全局数据区，直到程序运行结束。但其作用域为局部作用域，当定义它的函数或语句块结束时，其作用域随之结束；

### static 函数
在函数的返回类型前加上static关键字,函数即被定义为静态函数。静态函数与普通函数不同，它只能在声明它的文件当中可见，不能被其它文件使用。

## const
定义变量时的限定符，表示变量值不能改变

## inline
为了解决频繁调用的小函数大量消耗栈空间的问题，从而引入了inline修饰符，表示为内联修饰符
将任何调用函数的地方都替换成了对应函数内的表达式

### inline仅仅是对一个编译器的建议
inline函数仅仅是对一个编译器的建议，对于是否真正内联，还要看编译器的意思

如果在每个文件里都实现一次该内联函数的话，那么，最好保证每个定义都是一样的，否则，将会引起未定义的行为。如果不是每个文件里的定义都一样，那么，编译器展开的是哪一个，那要看具体的编译器而定。所以，最好将内联函数定义放在头文件中。

内联是以代码膨胀(复制为代价的）仅仅省去了调用函数的开销，提高函数的指向效率，但会使程序的总代码量提高，消耗更多的内存

### 总结
内联函数并不是一个增强性能的灵丹妙药。只有当函数非常短小的时候它才能得到我们想要的效果；
但是，如果函数并不是很短而且在很多地方都被调用的话，那么将会使得可执行体的体积增大。

## explicit
指定构造函数或转换函数（c++11起）为显示，不能用于隐式转化和复制初始化

被声明为explicit的构造函数通常比其 non-explicit 兄弟更受欢迎, 因为它们禁止编译器执行非预期 (往往也不被期望) 的类型转换.
除非我有一个好理由允许构造函数被用于隐式类型转换, 否则我会把它声明为explicit. 我鼓励你遵循相同的政策.


## volatile

