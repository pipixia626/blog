# c++中的多态机制


## 静态多态

## 动态多态

### 虚函数

在类的定义中，带有virtual关键字的成员函数称为虚函数

```
class Base 
{
    virtual int Fun() ; // 虚函数
};

int Base::Fun() // virtual 字段不用在函数体时定义
{ }
```
### 虚表
动态绑定计数：虚表
每个包含了虚函数的类都包含一个虚表

虚表是一个指针数组，其元素是虚函数的指针，每个元素对应一个虚函数的函数指针，
虚表的元素不包括普通函数的函数指针
虚表是在编译时期构造出来的
![虚表示意图]("https://github.com/pipixia626/blog/blob/main/c%2B%2B/image/virtual_table.png")

### 虚表指针
虚表是属于类的，而不是属于某个具体的对象，一个类只需要一个虚表就可以，同一个类的所有对象都使用同一个虚表

为了指定对象的虚表，对象内部包含一个虚表的指针，来指向自己所使用的虚表，为了让每个包含虚表的类的羞羞都用于一个虚表指针
编译器在类中添加了一个指针`* _vptr` ,用来指向虚表，当类的创建时便拥有了这个指针，这个指针自动被设置为类的虚表

象的虚表指针用来指向自己所属类的虚表，虚表中的指针会指向其继承的最近的一个类的虚函数

### 多态表现形式
把经过虚表调用虚函数的过程称为动态绑定，其表现出来的现象称为运行时多态

动态绑定区别于传统的函数调用，传统的函数调用称之为静态绑定，即在函数的调用在编译阶段就可以确定下路了
通过指针来调用函数

1：派生类的指针赋给基类指针

通过基类指针调用基类和派生类中同名虚函数时：

调用哪个虚函数，取决于指针对象指向哪种类型的对象
```
class CFather 
{
public:
    virtual void Fun() { } // 虚函数
};

// 派生类
class CSon : public CFather 
{ 
public :
    virtual void Fun() { }
};

int main() 
{
    CSon son;
    CFather *p = &son;
    p->Fun(); //调用哪个虚函数取决于 p 指向哪种类型的对象
    return 0;
}

```
2：派生类的对象可以赋给基类引用
调用哪个虚函数，取决于引用的对象是哪种类型的对象

```
// 基类
class CFather 
{
public:
    virtual void Fun() { } // 虚函数
};

// 派生类
class CSon : public CFather 
{ 
public :
    virtual void Fun() { }
};

int main() 
{
    CSon son;
    CFather &r = son;
    r.Fun(); //调用哪个虚函数取决于 r 引用哪种类型的对象
    return 0;
}
}
```




