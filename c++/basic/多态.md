# c++中的多态机制


## 静态多态
函数重载，模板，泛型编程
## 动态多态

### 虚函数

在类的定义中，带有virtual关键字的成员函数称为虚函数

```
class Base 
{
    virtual int Fun() ; // 虚函数
};

int Base::Fun() // virtual 字段不用在函数体时定义
{ }
```
### 虚表
动态绑定计数：虚表
每个包含了虚函数的类都包含一个虚表

虚表是一个指针数组，其元素是虚函数的指针，每个元素对应一个虚函数的函数指针，
虚表的元素不包括普通函数的函数指针
虚表是在编译时期构造出来的
![虚表示意图](https://github.com/pipixia626/blog/blob/main/c%2B%2B/image/virtual_table.png)

### 虚表指针
虚表是属于类的，而不是属于某个具体的对象，一个类只需要一个虚表就可以，同一个类的所有对象都使用同一个虚表

为了指定对象的虚表，对象内部包含一个虚表的指针，来指向自己所使用的虚表，为了让每个包含虚表的类的羞羞都用于一个虚表指针
编译器在类中添加了一个指针`* _vptr` ,用来指向虚表，当类的创建时便拥有了这个指针，这个指针自动被设置为类的虚表

象的虚表指针用来指向自己所属类的虚表，虚表中的指针会指向其继承的最近的一个类的虚函数
![虚表和对象](https://github.com/pipixia626/blog/blob/main/c%2B%2B/image/virtual_table2.png)
### 多态表现形式
把经过虚表调用虚函数的过程称为动态绑定，其表现出来的现象称为运行时多态

动态绑定区别于传统的函数调用，传统的函数调用称之为静态绑定，即在函数的调用在编译阶段就可以确定下路了
通过指针来调用函数

1：派生类的指针赋给基类指针

通过基类指针调用基类和派生类中同名虚函数时：

调用哪个虚函数，取决于指针对象指向哪种类型的对象
```
class CFather 
{
public:
    virtual void Fun() { } // 虚函数
};

// 派生类
class CSon : public CFather 
{ 
public :
    virtual void Fun() { }
};

int main() 
{
    CSon son;
    CFather *p = &son;
    p->Fun(); //调用哪个虚函数取决于 p 指向哪种类型的对象
    return 0;
}

```
2：派生类的对象可以赋给基类引用
调用哪个虚函数，取决于引用的对象是哪种类型的对象

```
// 基类
class CFather 
{
public:
    virtual void Fun() { } // 虚函数
};

// 派生类
class CSon : public CFather 
{ 
public :
    virtual void Fun() { }
};

int main() 
{
    CSon son;
    CFather &r = son;
    r.Fun(); //调用哪个虚函数取决于 r 引用哪种类型的对象
    return 0;
}
}
```
## 菱形继承
最下面的类对象内存布局中有相同的父类以及父类的多个子类的实例的数据成员，引起程序歧义
虽然可以通过指明调用路径以消除二义性，但二义性的潜在性还没有消除，可以使用虚继承的方法
来消除

## 虚继承
解决了菱形继承中最派生类拥有多个间接父类实例的情况

参考虚继承.md





