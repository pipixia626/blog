# 8种类默认的函数

## preview

只是声明一个空类，不做任何事情的话，编译器会自动为你生成一个默认构造函数，默认拷贝构造哈桑怒，一个默认重载赋值操作运算符函数和一个默认析构函数，这些函数只有在第一次被调用时，才会被编译器创建，这几个生成的默认函数的实现就是什么都不做。所有这些函数都是inline和public的

对应函数的标识符 ，来控制这些函数是否被使用

1. default :被标识的默认函数将使用类的默认行为 A()=default;
2. delete :被标识的默认函数将被禁用 A()=delete
3. override:被标识的函数需要强制重写基类虚函数
4. final:被标识的函数禁止重写基类虚函数
   

## 构造函数
`A();`
### 作用
将对象进行初始化 ，在堆上new一个对象或在栈上定义一个临时对象时，会自动调用对象的构造函数

### 方式
- 初始化列表方式
在初始化对象时更高效，减少了一次赋值操作
- 以下成员变量必须在初始化列表中初始化
常量成员变量，引用类型成员变量，没有缺省的构造函数的成员变量
### 注意
1. 函数名与类名相同，可以重载，不能为虚函数，不能有返回值，连void也不行；
2. 如果没有显式定义，编译器会自动生成一个默认的构造函数，默认的构造函什么都不会做；
3. 对于出现单参数的构造函数需要注意，C++会默认将参数对应的类型转换为该类类型，有时候这种隐式的转换是我们不想要的，需要使用explicit关键字来限制这种转换；
4. 无参构造函数和带有缺省值的构造函数（全缺省）都认为是缺省的构造函数，并且缺省的构造函数只能有一个；
5. 函数体内可以使用this指针，但不可以用于初始化列表。
因为构造函数只是初始化对象，初始化之前此对象已经存在了，所以可以有this，函数体里面是进行赋值，
初始化列表是对类中的各个成员变量进行初始化，初始化的位置对象不完整，所以不能使用this用于初始化列表；

### 构造顺序
虚拟基类的构造函数（如果有多个虚拟基类，按照它们被继承的顺序构造，而不是它们在成员初始化列表中的顺序）；

非虚拟基类的构造函函（如果有多个非虚拟基类，按照它们被继承的顺序构造，而不是它们在成员初始化列表中的顺序）；

成员对象的构造函数（如果有多个成员类对象，按照它们声明的顺序调用，而不是它们在成员初始化列表中的顺序）；

本类构造函数。构造的过程是递归的。

## 拷贝构造函数
实际上是构造函数的重载，具有一般构造函数的所有特性，用此类已有对象创建一个新的对象，一般在函数中会将已存在的对象的数据成员复制一份到新的对象中，用类的一个已知的对象取初始化该类的另一个对象时，会自动调用对象的拷贝构造函数
`A(const A&);`

### 深拷贝和浅拷贝
编译器创建的默认拷贝构造函数只会执行"浅拷贝"，也就是通过赋值完成，如果该类的数据成员中有指针成员，也只是地址的拷贝，会使得新的对象与拷贝对象该指针成员指向的地址相同，delete该指针时则会导致两次重复delete而出错，如果指针成员是new出来就是“深拷贝”。

## 析构函数
`~A();`
### 作用
做一些清理工作，delete一个对象或对象生命周期结束时，会自动调用对象的析构jams
## 重载赋值运算符函数
`A& operator=(const A&)`
### 作用
1. 它是两个已有对象，一个给另一个赋值的过程，当两个对象之间进行赋值时，会自动调用重载赋值运算符函数，不同于拷贝构造函数，拷贝构造函数是用已有对象给新生成的对象赋初值的过程
2. 赋值运算符重载函数参数中const和&没有强制要求，返回值是类对象的引用，通过返回引用值可以实现连续赋值 类似a=b=c;
3. 不能是静态成员函数，也不能是友元函数，不能被继承，要避自赋值
4. 默认的赋值运算符重载函数实现将数据成员逐一赋值的一种浅拷贝，会导致指针悬挂问题。
## 重载取址运算符函数
`A* operator &();`
### 作用
1. 重载取址运算符函数没有参数；
2. 如果没有显式定义，编译器会自动生成默认的重载取址运算符函数，函数内部直接return this，一般使用默认即可。
## 重载取地址运算符const函数
`const A* operator &(); const `
### 作用
一样，保证this对象不做修改
## 移动构造函数和重载移动赋值操作符函数

### 作用
move 语义：将原对象资源的控制权交给目标对象，可以将原对象移动到新对象，用于a初始化b后，就将a析构

### 注意
1. 移动构造函数的参数和拷贝构造函数不同，拷贝构造函数的参数是一个左值引用，但是移动构造函数的初值是一个右值引用；
2. 临时对象即将消亡，并且它里面的资源是需要被再利用的，这个时候就可以使用移动构造。移动构造可以减少不必要的复制，带来性能上的提升