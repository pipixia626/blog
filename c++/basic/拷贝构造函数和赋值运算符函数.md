# 必要性和意义

## 拷贝构造函数和赋值运算符
默认情况下（用户没有定义，但是也没有显示的删除）编译器自动地生成一个拷贝构造函数和赋值运算符
```
class Person
{
  public:
  ...
    Person(const Person& p) = delete; 
    Person& operator=(const Person& p) = delete;

  private:
    int age;
    string name;
};
```
- 使用delete来指定不生成->对象不能通过值传递也不能进行赋值运算

### 私有的拷贝构造函数和赋值运算符

为了自己不想编写拷贝构造函数和赋值运算符，而且不允许别人使用编译器隐式生成的缺省函数，同时又不想显示地删除拷贝构造函数和赋值运算符函数

### 需要注意的

1. 拷贝构造函数必须以引用的方式传递参数（传常量引用的方式） ->在Pass by value的方式传递参数给一个函数时，会调用拷贝构造函数生成的实参，如果拷贝构造函数的参数仍然是以pass by value的方式，就会不断循环下去，直到函数的栈溢出

2. 赋值运算符函数的返回值类型要声明为该类型的引用，并在函数结束前返回实例自身的引用（*this)
只有返回一个引用，才能进行连续的赋值

### 区别
拷贝构造函数使用传入对象的值生成一个新的对象的实例
创建一个新的对象实例

赋值运算符函数是将对象的值赋值给一个已经存在的实例
将一个对象的值复制给另一个已经存在的对象

总而言之：有无产生新的对象实例，有就是调用拷贝构造函数，没有就是对已有对象赋值

### 深拷贝和浅拷贝
c++类的拷贝又两种：深拷贝和浅拷贝
当出现类的等号赋值时，会调用拷贝函数

#### 浅拷贝和深拷贝的区别

- 未定义显示拷贝构造函数的情况下，系统会调用默认的拷贝函数 -即为浅拷贝，能够完成成员的一一复制。当数据成员中没有指针时，浅拷贝是可行的；但当数据成员有指针时，如果采用简单的浅拷贝，则两类中的两个指针将指向同一个地址，当对象快结束时，会调用两次析构函数，而导致指针悬挂现象，此时就必须采用深拷贝

- 深拷贝和浅拷贝的区别就在于深拷贝会在堆内存中另外申请空间存储数据，从而解决了指针悬挂的问题
