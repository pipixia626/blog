# 虚函数

作用: 实现多态机制，多态，简单的来说是指在继承层次中，父类的指针具有多种形态，当它指向某个子类对象时，通过它能够调用到子类的函数，而非父类的函数

是一种运行时多态，即父类指针只有在程序运行时才能知道所指的真正类型是什么，这种运行期决议是通过虚函数表来实现的

## 使用指针访问虚函数表

当一个类本身定义了虚函数，或其父类有虚函数时，为了支持多态机制，比那一起将为该类添加一个虚函数指针（vptr)虚函数指针一般都放在对象内存布局上的第一个位置，这是为了保证在多层继承或多重继承的情况下能以最高效率取到虚函数表


```
class Base{
    public:
    Base(int i):baseI(i){};
     virtual void print(void){ cout << "调用了虚函数Base::print()"; }

    virtual void setI(){cout<<"调用了虚函数Base::setI()";}

    virtual ~Base(){}
    private:
    int baseI;
};
```
因此当vptr位于对象内存最前面时，对象的地址即为虚函数指针地址

从而取得虚函数指针的地址

```
Base base(10);
int *vptrAdree=(int*)(&base);
cout<<"虚函数指针的地址是："<<vptrAdree<<endl;

```
强行把类对象的地址转换为int*类型，取得虚函数指针的地址，虚函数指针指向虚函数表，虚函数表中存储的是一系列虚函数的地址，虚函数地址出现的顺序与类中虚函数声明顺序一致。对虚函数指针取地址值，可以得到虚函数表的地址，也就是虚函数表第一个虚函数的地址

```
typedef void*(*Fun)(void);
Fun vfunc=(Fun)*((int*)*(int*)(&base));
 cout << "第一个虚函数的地址是：" << (int *)*(int*)(&b) << endl;
 vfunc();
```
1. 把虚函数表指针取出来 *(int*)(&base),是虚函数表的地址
2. 对虚函数表取地址值 int*(int *)(&base) 就是第一个虚函数的地址，第二个地址就是(int *)(int *)(&base+1)
3. 转换成函数指针类型，通过函数指针就可以访问

