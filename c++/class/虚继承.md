# 虚继承

## 为什么要引入虚继承
虚拟继承是多重继承中特有的概念。虚拟基类是为解决多重继承而出现的。如:类D继承自类B1、B2，而类B1、B2都继承自类A，因此在类D中两次出现类A中的变量和函数。为了节省内存空间，可以将B1、B2对A的继承定义为虚拟继承，而A就成了虚拟基类
```
class A

class B1:public virtual A;

class B2:public virtual A;

class D:public B1,public B2
```
## 虚继承和直接继承的区别
由于有了间接性和共享性两个特征，所以决定了虚继承体系下的对象在访问时必然会在时间和空间上与一般情况有较大不同。

1. 时间：在通过继承类对象访问虚基类对象中的成员（包括数据成员和函数成员）时，都必须通过某种间接引用来完成，这样会增加引用寻址时间（就和虚函数一样），其实就是调整this指针以指向虚基类对象，只不过这个调整是运行时间接完成的。

2. 空间：由于共享所以不必要在对象内存中保存多份虚基类子对象的拷贝，这样较之多继承节省空间。虚拟继承与普通继承不同的是，虚拟继承可以防止出现diamond继承时，一个派生类中同时出现了两个基类的子对象。也就是说，为了保证这一点，在虚拟继承情况下，基类子对象的布局是不同于普通继承的。因此，它需要多出一个指向基类子对象的指针。

- 虚继承的子类，如果本身定义了新的虚函数，则编译器为其生成一个虚函数指针（vptr）以及一张虚函数表。该vptr位于对象内存最前面。
vs非虚继承：直接扩展父类虚函数表。

- 虚继承的子类也单独保留了父类的vprt与虚函数表。这部分内容接与子类内容以一个四字节的0来分界。

-  虚继承的子类对象中，含有四字节的虚表指针偏移值。
## 面试常考
第一种情况：　　　　　　　　 第二种情况：　　　　　　　　　　第三种情况　　　　　　　　　　　　第四种情况：
class a　　　　　　　　　　　class a　　　　　　　　　　　　  class a　　　　　　　　　　　　　　class a
{　　　　　　　　　　　　　 {　　　　　　　　　　　　　　　 {　　　　　　　　　　　　　　　　　{
    virtual void func();　　　　　　virtual void func();　　　　　　　virtual void func();　　　　　　　　virtual void func();
};　　　　　　　　　　　　　 };　　　　　　　　　　　　　　　　　 char x;　　　　　　　　　　　　　　char x;
class b:public virtual a　　　class b :public a　　　　　　　    };　　　　　　　　　　　　　　　　};
{　　　　　　　　　　　　　　{　　　　　　　　　　　　　　 　class b:public virtual a　　　　　 class b:public a
    virtual void foo();　　　　　　  virtual void foo();　　　　　{　　　　　　　　　　　　　　　　 {
};　　　　　　　　　　　　　 };　　　　　　　　　　　　　　　　　　virtual void foo();　　　　　　　　virtual void foo();
　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　};　　　　　　　　　　　　　　　　};

如果对这四种情况分别求sizeof(a）,  sizeof(b)。结果是什么样的呢？下面是输出结果：
第一种：4，12
第二种：4，4
第三种：8，16
第四种：8，8

因为每个存在虚函数的类都要有一个4字节的指针指向自己的虚函数表，所以每种情况的类a所占的字节数应该是没有什么问题的，那么类b的字节数怎么算呢？看“第一种”和“第三种”情况采用的是虚继承，那么这时候就要有这样的一个指针vptr_b_a，这个指针叫虚类指针，也是四个字节；还要包括类a的字节数，所以类b的字节数就求出来了。而“第二种”和“第四种”情况则不包括vptr_b_a这个指针，这回应该木有问题了吧。


